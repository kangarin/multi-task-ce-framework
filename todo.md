### TODO

1. 把RabbitMQ版本示例应用改成通过环境变量传参（仿照MQTT），测试通过脚本启动容器。
2. 在这个版本上对接redis，测试通过redis修改优先级，需要写一个简单的调度器、控制节点和执行节点的逻辑：调度器修改优先级、实例分配节点位置，通过redis写入最新配置；执行节点通过redis读取最新配置并且执行增减实例；实例通过redis读取最新配置并且改变自身优先级和其他应用相关参数。
3. 控制节点实际上不需要对执行节点做太多的“控制”，执行节点通过轮询配置自我管理自己，实际上是由调度器“控制”。控制节点主要需要维护一个应用列表，包括应用名、实例数、实例分配节点位置、实例优先级、实例状态（运行中、停止、异常）等。控制节点与执行节点最主要的交互就是心跳。控制节点还要做一些琐事，比如把用户提交的配置文件转为系统实际运行中需要的配置文件（填充一些缺省参数，如内部数据库、消息队列服务的地址等），汇总各个节点的状态转为调度器需要的格式，等等。控制节点还需要做镜像管理，确保执行节点上拥有指定的镜像，如果没有，需要传输过去。

亦即控制节点主要做应用管理+镜像管理。

### 流程梳理
用户提供生成好的docker镜像，以及配置文件（包括应用的结构，消息队列的类型、主题，每个微服务的实例数，端口映射，网络配置等等，暂时只考虑用户手动增减实例，调度器是负责放置在特定节点的，但不负责增减实例，后续可以通过用户代理执行增减实例？）。
用户提交配置文件后，控制节点需要做的事情：
1. 配置文件校验
2. 配置文件转换
3. 加入应用列表，等待调度器做出首次冷启动调度

调度器视角下，它应该看到一个应用列表，这个应用列表由控制节点动态维护。它只负责不断对每个应用执行最新的调度策略。调度策略包括：
1. 微服务优先级调整
2. 实例分配节点位置