### 概述
本项目是一个微服务应用的管理平台。
节点有两类：控制节点和执行节点。控制节点负责管理执行节点，执行节点负责执行应用。每个节点对应一台物理机（云节点或边缘节点）。

### 节点
#### 控制节点
控制节点负责管理执行节点，包括维护在线节点状态信息、分配应用到执行节点、监控执行节点运行状态等。控制节点向上提供用户管理接口（与前端界面及调度器交互），向下提供节点管理接口（与执行节点交互）。控制节点的逻辑较为high-level，单例部署在云端。

控制节点应当通过数据库维护以下几部分信息：
1. 所有在线节点的ip地址
2. 所有在线节点的状态信息
3. 所有应用的部署信息（包括应用名、服务名、实例序号、节点ip、容器名等），逻辑上，一个应用对应一张表或配置文件，当调度策略更新时，修改该配置文件

控制节点应当具有以下功能接口：

1. 获取在线节点列表（GET）
获取在线执行节点的列表，无参数

2. 获取节点状态（GET）
获取某个执行节点的状态，参数如下：
- 节点ip（node_ip）：节点的ip地址


#### 执行节点
执行节点负责执行应用，包括启动应用、停止应用、监控应用运行状态等。执行节点向上提供节点管理接口（与控制节点交互），向下提供容器化应用管理接口。执行节点的逻辑较为low-level，部署在云端（作为较强的执行节点）和边缘端（较弱的执行节点）。

启动应用和停止应用不通过http请求，而是不断轮询数据库，查询本节点应当部署的应用，然后启动或停止相应的容器。对用户透明。

执行节点应当具有以下功能接口：

<!-- 1. 启动应用（POST）
在本节点上启动一个docker容器，参数如下：
- 镜像名（image_name）：如video_generator，video_processor_stage_1等预先构建好的镜像
- 环境变量（env）：如消息队列的ip地址
- 端口映射（port_map）：宿主机端口-容器端口，仅aggregator需要
- 挂载目录（volume_map）：宿主机目录-容器目录，暂时不需要写
- 网络（network）：应用名，如head_up_test
- 容器名（container_name）：应用名+服务名+实例序号（全局唯一，由控制节点维护），如head_up_test_video_generator_1

2. 停止应用（POST）
停止一个容器，参数如下：
- 容器名（container_name）：应用名+服务名+实例序号 -->

1. 监控应用运行状态（GET）
获取一个容器的运行状态，参数如下：
- 容器名（container_name）：应用名+服务名+实例序号

2. 获取节点状态（GET）
获取本节点的状态，无参数

### 网络
一个应用应当在每个执行节点上有一个docker network，创建命令如下：
```bash
docker network create app-network
```
应用中的所有微服务都应当加入这个网络，这样就可以通过服务名来访问他们，而不是通过ip地址，这样可以避免ip地址变化带来的问题。
微服务之间通过消息队列通信，消息队列的ip是全局唯一的，可以通过环境变量传入微服务中。经测试，docker network中的容器可以访问公网。

### 应用相关参数调整方法
与执行节点启停容器逻辑一样，参数调整通过“拉”的方式，即不断轮询数据库，查询本应用相关最新参数并及时调整，如调整视频生成器的帧率、分辨率，微服务的优先级等。

### TODO
1. docker开启远程访问（可有可无，可以通过节点的tcp连接交互）
2. 数据库存储节点信息
3. distributor的topic转换逻辑需要理清，现在太乱